#!/usr/bin/env python3
''' counter_simon.py

This program runs the Simon cipher in counter mode.

The input to Simon is the nonce appended with the counter.

The input data should be a bytes object. The output data is a bytes object.
The key and nonce are 256-bit and 64-bit integers, respectively.

The key generated by Simon is XOR'd with the input to encrypt or decrypt it.
'''


import simon
import time
import argparse as ap
import sys

def simon_counter_mode(input_data, input_key, nonce):
    # confirm the inputs are valid
    if type(input_data) is not bytes:
        raise TypeError("input must be bytes object")
    if type(input_key) is not int or type(nonce) is not int:
        raise TypeError("input_key and nonce must be integers")
    if input_key.bit_length() > 256:
        raise ValueError("input_key cannot exceed 256 bits")
    if nonce.bit_length() > 64:
        raise ValueError("nonce cannot exceed 64 bits")

    # set the nonce to 128 bits to create the input to Simon
    # note: the nonce will be the uppermost bits of the input
    counter = nonce << 64

    key_words = simon.bytes_to_words(input_key, 32)
    key = simon.key_schedule(key_words)

    output_data = bytes()

    lower_index = 0
    upper_index = 16
    max_index = len(input_data)
    # read a block from the input and encrypt/decrypt it until all blocks are done
    input_block_bytes = input_data[lower_index:min(upper_index, max_index)]
    while(len(input_block_bytes) > 0):
        input_block_int = int.from_bytes(input_block_bytes, 'little')

        # create the block key
        counter_words = simon.bytes_to_words(counter, 32)
        block_key_words = simon.encrypt(counter_words, key)
        block_key = simon.words_to_bytes(block_key_words)
        counter += 1

        # if input is under 128 bits long, truncate block key accordingly
        if (len(input_block_bytes)) < 16:
            block_key_trunc_mask_str = "0x" + \
                    ("f" * 2 * (len(input_block_bytes)))
            block_key_trunc_mask = int(block_key_trunc_mask_str, 16)
            block_key &= block_key_trunc_mask

        output_block_int = block_key ^ input_block_int
        output_block_bytes = output_block_int.to_bytes(
                len(input_block_bytes), 'little')
        output_data += output_block_bytes

        lower_index += 16
        upper_index += 16
        input_block_bytes = \
            input_data[min(lower_index, max_index):min(upper_index, max_index)]

    return output_data


if __name__ == "__main__":

    parser = ap.ArgumentParser(description=
            "Block mode encryption/decryption using Simon as a key generator")
    parser.add_argument("input", type=str,
            help="hex string containing data to encrypt/decrypt")
    parser.add_argument("key", type=str,
            help="hex string containing shared 256-bit key")
    parser.add_argument("nonce", type=str,
            help="hex string containing a 64-bit nonce to use as an IV")

    args = parser.parse_args()

    input_data = int(args.input, 16)
    from math import ceil
    input_data = input_data.to_bytes(ceil((len(hex(input_data))-2)/2), 'little')
    key = int(args.key, 16)
    nonce = int(args.nonce, 16)

    output = int.from_bytes(simon_counter_mode(input_data, key, nonce), 'little')
    output_str = "0x{:0" + str(2 * len(input_data)) + "x}"
    print(output_str.format(output))

