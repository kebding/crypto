#!/usr/bin/env python3
'''
This script runs the Simon cipher. For info on how to use it, run the script
with the -h/--help flag. 
'''

import argparse as ap

def argparse_hex(x):
    return int(x, 16)

parser = ap.ArgumentParser(description="Simon cipher encryption script")
parser.add_argument("-i", "--input", dest="input", 
        type=argparse_hex, metavar="<input>", 
        help="input to encrypt/decrypt. 128-bit hex value",
        default=0x697320612073696d6f6f6d20696e2074)
parser.add_argument("-k", "--key", dest="key", type=argparse_hex, 
        metavar="<key>", help="key to encrypt/decrypt with. 256-bit hex value",
        default=
            0x000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f)
parser.add_argument("-s", "--simple", dest="simple", action="store_true", 
        default=False, help="use simple Simon encryption")
parser.add_argument("-d", "--decrypt", dest="decrypt", action="store_true", 
        default=False, help="decrypt the input instead of encrypting it")
parser.add_argument("-t", "--test", dest="test", action="store_true", 
        default=False, help="run unit tests. overrides -i and -k")
parser.add_argument("-v", "--verbose", dest="verbose", action="store_true",
        default=False, help="provide verbose output")
args = parser.parse_args()

#print("input={}, key={}, simple={},decrypt={}".format(args.input, args.key, args.simple, args.decrypt))

################################################################################
# functions

mask64 = 0xffffffffffffffff

# This function rotates the 64-bit input x to the left by r
def rotl64(x, r):
    # if rotation amount exceeds word length, get modular equivalence
    if r >= 64:
        r %= 64
    return ( ((x << r) & mask64) | (x >> (64-r)) )

# This function rotates the 64-bit input x to the right by r
def rotr64(x, r):
    # if rotation amount exceeds word length, get modular equivalence
    if r >= 64:
        r %= 64
    return ( (x >> r) | ((x << (64-r)) & mask64) )

# This function converts an integer into a list of 64-bit words, little-endian
def bytes_to_words(bytelist, numbytes):
    wordlist = []
    word = 0
    for i in range(numbytes):
        word = (word << 8) | ((bytelist >> (i * 8)) & 0xff)
        if (i+1) % 8 == 0:  # 8 bytes per 64-bit word, zero-indexed
            wordlist.append(word)
            word = 0
    return wordlist

# This function converts a list of 64-bit words into a single large integer
def words_to_bytes(words):
    out = 0
    for i in range(len(words)-1, -1, -1):
        for j in range(8):
            out = (out << 8) | ((words[i] >> (j * 8)) & 0xff)
    return out

# This function generates the key schedule for a given key k and stores each
# round key in the list rk
#
# k: a list of 64-bit words that form the encryption key
# rk: an empty list that will be filled with the round keys generated by k
def key_schedule(k):
    rk = [0 for i in range(72)]

    D = k[0]
    C = k[1]
    B = k[2]
    A = k[3]
    c = 0xfffffffffffffffc
    z = 0xfdc94c3a046d678b

    i = 0
    while i < 64:
        rk[i] = A
        i += 1
        A = A ^ c ^ (z & 1) ^ rotr64(D, 3) ^ rotr64(D, 4) ^ B ^ rotr64(B, 1)
        z >>= 1

        rk[i] = B
        i += 1
        B = B ^ c ^ (z & 1) ^ rotr64(A, 3) ^ rotr64(A, 4) ^ C ^ rotr64(C, 1)
        z >>= 1

        rk[i] = C
        i += 1
        C = C ^ c ^ (z & 1) ^ rotr64(B, 3) ^ rotr64(B, 4) ^ D ^ rotr64(D, 1)
        z >>= 1

        rk[i] = D
        i += 1
        D = D ^ c ^ (z & 1) ^ rotr64(C, 3) ^ rotr64(C, 4) ^ A ^ rotr64(A, 1)
        z >>= 1

    rk[64] = A
    A = A ^ c ^ 0 ^ rotr64(D, 3) ^ rotr64(D, 4) ^ B ^ rotr64(B, 1)
    rk[65] = B
    B = B ^ c ^ 1 ^ rotr64(A, 3) ^ rotr64(A, 4) ^ C ^ rotr64(C, 1)
    rk[66] = C
    C = C ^ c ^ 0 ^ rotr64(B, 3) ^ rotr64(B, 4) ^ D ^ rotr64(D, 1)
    rk[67] = D
    D = D ^ c ^ 0 ^ rotr64(C, 3) ^ rotr64(C, 4) ^ A ^ rotr64(A, 1)

    rk[68] = A
    rk[69] = B
    rk[70] = C
    rk[71] = D

    return rk

# This function is Simon's f-box
def f64(x):
    if args.simple:
        return ((rotl64(x, 1) ^ rotl64(x, 8)) ^ rotl64(x, 2))
    else:
        return ((rotl64(x, 1) & rotl64(x, 8)) ^ rotl64(x, 2))

    
# This function performs one round of Simon
def simon_round(left, right, k1):
    #print("simon_round")
    #print("left = {}, right = {}, k1 = {}, k2 = {}".format(
    #    hex(left), hex(right), hex(k1), hex(k2)))
    next_left = right ^ f64(left) ^ k1
    next_right = left
    #print("left = {}, right = {}".format(hex(left), hex(right)))
    return [next_left, next_right]

# This function takes the input plaintext and round keys and returns the output
# ciphertext. 
#
# plaintext: a list of two 64-bit words to encrypt
# keys: a list of round keys as generated by key_schedule()
def encrypt(pt, keys):
    ct = [pt[0], pt[1]]
    for i in range(72):
        ct = simon_round(ct[0], ct[1], keys[i])
        if args.verbose or args.test:
            print("Pt_{}=({},{})".format(i, hex(ct[0]), hex(ct[1])))
    return ct

# This function takes the input ciphertext and round keys and returns the output
# plaintext.
def decrypt(ct, keys):
    pt = [ct[1], ct[0]]
    for i in range(71, -1, -1):
        pt = simon_round(pt[0], pt[1], keys[i])
    pt.reverse()
    return pt


################################################################################
# main functions

def main():
    pre = bytes_to_words(args.input, 16)
    key = bytes_to_words(args.key, 32)
    round_keys = key_schedule(key)

    print("input:  " + hex(args.input))
    print("key:    " + hex(args.key))
    print("mode: ", end="")
    if args.decrypt:
        print("decrypt")
    else:
        print("encrypt")

    if args.verbose:
        print("output: ")
    if (args.decrypt):
        post = decrypt(pre, round_keys)
    else:
        post = encrypt(pre, round_keys)
    output = words_to_bytes(post)
    if not args.verbose:
        print("output: {}".format(hex(output)))

    if args.verbose:
        print("key schedule:")
        for i in range(len(round_keys)):
            print("  rk[{}]={}".format(i, hex(round_keys[i])))

def run_tests():
    # test rotation functions
    base = 0x0123456789abcdef
    expected = []
    expected.append(0xef0123456789abcd)
    expected.append(0xcdef0123456789ab)
    expected.append(0xabcdef0123456789)
    expected.append(0x89abcdef01234567)
    expected.append(0x6789abcdef012345)
    expected.append(0x456789abcdef0123)
    expected.append(0x23456789abcdef01)
    expected.append(0x0123456789abcdef)
    outs = []
    for i in range(len(expected)):
        outs.append(rotr64(base, (i+1)*8))
    if outs != expected:
        print("rotr64() failed.\nexpected:{}\nactual:  {}".format(
            [hex(i) for i in expected], [hex(i) for i in outs]))

    expected = []
    expected.append(0x23456789abcdef01)
    expected.append(0x456789abcdef0123)
    expected.append(0x6789abcdef012345)
    expected.append(0x89abcdef01234567)
    expected.append(0xabcdef0123456789)
    expected.append(0xcdef0123456789ab)
    expected.append(0xef0123456789abcd)
    expected.append(0x0123456789abcdef)
    outs = []
    for i in range(len(expected)):
        outs.append(rotl64(base, (i+1)*8))
    if outs != expected:
        print("rotl64() failed.\nexpected:{}\nactual:  {}".format(
            [hex(i) for i in expected], [hex(i) for i in outs]))


    # test byte-to-word conversions
    base64 = base
    base128 = 0xffffffffffffffff0123456789abcdef
    base256 = base128 | (base128 << 128)
    expected_words128 = [0xefcdab8967452301, 0xffffffffffffffff]
    expected_words256 = [0xefcdab8967452301, 0xffffffffffffffff,
            0xefcdab8967452301, 0xffffffffffffffff]
    words128 = bytes_to_words(base128, 16)
    words256 = bytes_to_words(base256, 32)
    if words128 != expected_words128:
        print("bytes_to_words 128 failed.\nexpected:{}\nactual:  {}".format(
            hex(expected_words128), hex(words128)))
    if words256 != expected_words256:
        print("bytes_to_words 256 failed.\nexpected:{}\nactual:  {}".format(
            hex(expected_words256), hex(words256)))

    # test word-to-byte conversions
    bytes128 = words_to_bytes(words128)
    bytes256 = words_to_bytes(words256)
    if (bytes128 != base128):
        print("words_to_bytes 128 failed.\nexpected:{}\nactual:  {}".format(
            hex(base128), hex(bytes128)))
    if (bytes256 != base256):
        print("words_to_bytes 256 failed.\nexpected:{}\nactual:  {}".format(
            hex(base256), hex(bytes256)))

    # test key schedule generator
    key = 0x000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f
    print("key   = {}".format(hex(key)))
    keywords = [0x1f1e1d1c1b1a1918,0x1716151413121110,0x0f0e0d0c0b0a0908,0x0706050403020100]
    gen_keywords = bytes_to_words(key, 32)
    if gen_keywords != keywords:
        print("bytes_to_words(key) failed.\nexpected:{}\nactual:  {}".format(
            [hex(i) for i in keywords], [hex(i) for i in gen_keywords]))
        print("using expected keywords for key schedule test.")

    keys = key_schedule(keywords)

    expected_keys = [0 for i in range(72)]
    expected_keys[0]=0x0706050403020100
    expected_keys[36]=0xa31b3abe8076f610
    expected_keys[1]=0x0f0e0d0c0b0a0908
    expected_keys[37]=0x3dfb6c156f4fe4b6
    expected_keys[2]=0x1716151413121110
    expected_keys[38]=0x623eba5ca89b0f90
    expected_keys[3]=0x1f1e1d1c1b1a1918
    expected_keys[39]=0xd1897281dd94af28
    expected_keys[4]=0x7262d303b0a011c3
    expected_keys[40]=0xe8cba626810ac017
    expected_keys[5]=0xb5069a3da370ec49
    expected_keys[41]=0x12b0ba3ed4576710
    expected_keys[6]=0x5588439d9423e835
    expected_keys[42]=0x27f1928653f59243
    expected_keys[7]=0xd45bd42be7d3bc42
    expected_keys[43]=0x6459d3334ca51ba4
    expected_keys[8]=0x95d63c18ff10381e
    expected_keys[44]=0xc61219ad9dd719bd
    expected_keys[9]=0x8e52a3d392ae0b18
    expected_keys[45]=0x3de57cab3bc05122
    expected_keys[10]=0x8d2efc1b34995478
    expected_keys[46]=0xea19af8c9239f4fe
    expected_keys[11]=0x6dee39824d6ed866
    expected_keys[47]=0x8d5f96bebb02d0ea
    expected_keys[12]=0x08311575366dfffd
    expected_keys[48]=0xe3842f10f8d8e8e1
    expected_keys[13]=0xcb91edc3362f6aa1
    expected_keys[49]=0x7f473c0d0f8c33cd
    expected_keys[14]=0x0c0305c3f518042e
    expected_keys[50]=0xa60a99d3fa4cf6d9
    expected_keys[15]=0x3f7809565e38a75e
    expected_keys[51]=0xce47ab7e80a4e231
    expected_keys[16]=0xfd8f7017ca8e416e
    expected_keys[52]=0xf9b3fd3cb773ef52
    expected_keys[17]=0x0e058c1d43bdbf5e
    expected_keys[53]=0x851a56bcaa80029b
    expected_keys[18]=0xf2181e83078f633c
    expected_keys[54]=0xb863f7519abd9a76
    expected_keys[19]=0x12adbc8dde87232f
    expected_keys[55]=0x085816bcb96d6fde
    expected_keys[20]=0x1808a9a2b12a4835
    expected_keys[56]=0x6055fc9debf7687e
    expected_keys[21]=0x886ffd8e453d7f85
    expected_keys[57]=0xb4b845e0615d31a2
    expected_keys[22]=0x7f9783dee5405671
    expected_keys[58]=0x363499ae8aa7c894
    expected_keys[23]=0x41553647fa3bbf54
    expected_keys[59]=0x627d313f6160c9f9
    expected_keys[24]=0x6790a0b8a992bb91
    expected_keys[60]=0xcb2611465fc12b50
    expected_keys[25]=0x8d475e5cb28981fa
    expected_keys[61]=0x73bfcc5aff52d55f
    expected_keys[26]=0x18eb4f6b40e06152
    expected_keys[62]=0x03c4cabf5497ed92
    expected_keys[27]=0x0861e447248dacce
    expected_keys[63]=0x537302d9f1650b97
    expected_keys[28]=0x72018cf92b796a3f
    expected_keys[64]=0x61e094b881ff9a96
    expected_keys[29]=0x7f46602d1a3e9419
    expected_keys[65]=0x2444879966513b02
    expected_keys[30]=0x53590cf77b30dfc4
    expected_keys[66]=0x603d6e7f1810a8e3
    expected_keys[31]=0xf3c1e06cfd629a16
    expected_keys[67]=0xa79858eadd19bc25
    expected_keys[32]=0xfc5f013613dd3135
    expected_keys[68]=0x46f321815d0b6faf
    expected_keys[33]=0x1a02056b802faef6
    expected_keys[69]=0x1729f70e33c7e362
    expected_keys[34]=0x846783a9cf1bf814
    expected_keys[70]=0x8801448e713eb772
    expected_keys[35]=0xd6841671bdbc0cc6
    expected_keys[71]=0xc46d2a8df85ca638

    if expected_keys != keys:
        print("key_schedule failed.")
        print("i  expected  actual")
        for i in range(len(keys)):
            print("{}\n    {}\n    {}".format(i,
                hex(expected_keys[i]), hex(keys[i])))
        print("using expected keys for encryption.")


    # test encryption function
    plaintext_bytes = 0x697320612073696d6f6f6d20696e2074
    print("input = {}".format(hex(plaintext_bytes)))
    plaintext_words = bytes_to_words(plaintext_bytes, 16)
    expected_plaintext_words = [0x74206e69206d6f6f,0x6d69732061207369]
    if plaintext_words != expected_plaintext_words:
        print("bytes_to_words(plaintext) failed.\nexpected:{}\nactual:  {}".format(
            [hex(i) for i in plaintext_words], 
            [hex(i) for i in expected_plaintext_words]))
        print("using expected value for encryption.")

    actual_ciphertext = encrypt(expected_plaintext_words, expected_keys)

    expected_ciphertext = [
        [0x9aae8780a3dd8180,0x74206e69206d6f6f], 
        [0x35917d66e1906065,0x9aae8780a3dd8180], 
        [0x5add05ceb6ae5104,0x35917d66e1906065], 
        [0xd4fb7dd40c633d64,0x5add05ceb6ae5104], 
        [0xd226f1953786d594,0xd4fb7dd40c633d64], 
        [0x0d27a09f770d077e,0xd226f1953786d594], 
        [0xb130314373932e55,0x0d27a09f770d077e], 
        [0x3d9cf3bbddb456cb,0xb130314373932e55], 
        [0xcaa460e14a12c473,0x3d9cf3bbddb456cb], 
        [0x1d1f12af77554cde,0xcaa460e14a12c473], 
        [0x29e4f311e7d63b6f,0x1d1f12af77554cde], 
        [0x97a3e749634b1f0c,0x29e4f311e7d63b6f], 
        [0x5c1d33431e81b4b1,0x97a3e749634b1f0c], 
        [0x347485802e628628,0x5c1d33431e81b4b1], 
        [0xe14d20801297a02f,0x347485802e628628], 
        [0xce380ed63f24a188,0xe14d20801297a02f], 
        [0x3c227fe3008a6762,0xce380ed63f24a188], 
        [0x10f09e477eb4c15a,0x3c227fe3008a6762], 
        [0xad781c7349970326,0x10f09e477eb4c15a], 
        [0xefad6347156de8e2,0xad781c7349970326], 
        [0x86877ec985c2285d,0xefad6347156de8e2], 
        [0x78d1ac6e45586693,0x86877ec985c2285d], 
        [0xcbf604ea7dc36541,0x78d1ac6e45586693], 
        [0x805881d48b6a0c43,0xcbf604ea7dc36541], 
        [0xad85a389fbfdef5e,0x805881d48b6a0c43], 
        [0xba0a50bc23ff6e6e,0xad85a389fbfdef5e], 
        [0x5d570e32738e7b2e,0xba0a50bc23ff6e6e], 
        [0xd5399c524f530845,0x5d570e32738e7b2e], 
        [0x53a0e38677bb3087,0xd5399c524f530845], 
        [0x44bdf46220b15f43,0x53a0e38677bb3087], 
        [0x9b7e5ef98f0c904a,0x44bdf46220b15f43], 
        [0xecd9d66bedf184ee,0x9b7e5ef98f0c904a], 
        [0x0dd42ea5fa97ba08,0xecd9d66bedf184ee], 
        [0xd1a36cdd12aac238,0x0dd42ea5fa97ba08], 
        [0x6c7ac76a5f674aae,0xd1a36cdd12aac238], 
        [0xee096d51f4c1600b,0x6c7ac76a5f674aae], 
        [0x7f441833cd143c97,0xee096d51f4c1600b],
        [0x6aea51cebff667ce,0x7f441833cd143c97],
        [0x768367c8ec326236,0x6aea51cebff667ce],
        [0xe06874ecc2cb445b,0x768367c8ec326236],
        [0x5fb9fa9de711bbee,0xe06874ecc2cb445b],
        [0x354db1868af9aaae,0x5fb9fa9de711bbee],
        [0xe5efac098ea08701,0x354db1868af9aaae],
        [0x0d26da91fcdfad0c,0xe5efac098ea08701],
        [0x152e4ec339a42284,0x0d26da91fcdfad0c],
        [0x4e361c36018f723e,0x152e4ec339a42284],
        [0xd3e3a197aeb23acf,0x4e361c36018f723e],
        [0x2f660ff810650c78,0xd3e3a197aeb23acf],
        [0xcbf3a97737f6fbee,0x2f660ff810650c78],
        [0xec4ec40fa6db36c7,0xcbf3a97737f6fbee],
        [0x9446289c1fe093a4,0xec4ec40fa6db36c7],
        [0x7319dd19797cbe64,0x9446289c1fe093a4],
        [0xa183b9f53dd9e127,0x7319dd19797cbe64],
        [0x730c1d597d3a3a60,0xa183b9f53dd9e127],
        [0xd1c823f169bcf290,0x730c1d597d3a3a60],
        [0xbc74c540f2d41ffc,0xd1c823f169bcf290],
        [0x308fcaef8d13d9a4,0xbc74c540f2d41ffc],
        [0xcbf92e93b5c7e8ce,0x308fcaef8d13d9a4],
        [0xb87df82a93237282,0xcbf92e93b5c7e8ce],
        [0x388bdf17ba686b3d,0xb87df82a93237282],
        [0x906383184503e11e,0x388bdf17ba686b3d],
        [0x2a391f2c53343808,0x906383184503e11e],
        [0x2b511946796cecac,0x2a391f2c53343808],
        [0x840e7ae4272a0927,0x2b511946796cecac],
        [0x5290826e6e3b50a0,0x840e7ae4272a0927],
        [0x6a08f088e1c6d0e4,0x5290826e6e3b50a0],
        [0x9a9eae3333b01b9a,0x6a08f088e1c6d0e4],
        [0xb3c6008cd21f10bb,0x9a9eae3333b01b9a],
        [0x55758d9122d717e8,0xb3c6008cd21f10bb],
        [0xd1b0d0e42f828428,0x55758d9122d717e8],
        [0x3bf72a87efe7b868,0xd1b0d0e42f828428],
        [0x8d2b5579afc8a3a0,0x3bf72a87efe7b868],
    ]

    if expected_ciphertext[71] != actual_ciphertext:
        print("encrypt failed.")
        print("expected_ciphertext:")
        for i in range(len(expected_ciphertext)):
            print("{}:  {},{}".format(i, 
                hex(expected_ciphertext[i][0]), hex(expected_ciphertext[i][1])))
        print(hex(expected_ciphertext[71][0]), hex(expected_ciphertext[71][1]))
        print(hex(actual_ciphertext[0]), hex(actual_ciphertext[1]))

    
    # test decryption
    decrypted_words = decrypt(actual_ciphertext, keys)
    decrypted_bytes = words_to_bytes(decrypted_words) 
    if decrypted_words != plaintext_words or \
            decrypted_bytes != plaintext_bytes:
        print("decryption failed.")
        print("decrypted_words = {}\nplaintext_words = {}".format(
            [hex(i) for i in decrypted_words], 
            [hex(i) for i in plaintext_words]))
        print("decrypted_bytes = {}\nplaintext_bytes = {}".format(
            hex(decrypted_bytes), hex(plaintext_bytes)))


    print("all tests complete")

if __name__ == "__main__":
    if args.test:
        run_tests()
    else:
        main()

